import { getParsedUrl } from "./helpers";
import { Environment } from "./types";

// @ts-ignore
// Manifest is generated by `/wrangler/build.ts`.
import functionManifest from "./_manifest";

function splitFunctionQuery(query: { [key: string]: string }, env: Environment) {
  const preview = query.preview ? query.preview === env.SECRET : false;
  const refresh = query.refresh ? query.refresh === env.SECRET : false;

  let rest = { ...query };
  delete rest.preview;
  delete rest.refresh;

  return {
    preview: preview || ("DEV" in env && "preview" in query),
    refresh: refresh || ("DEV" in env && "refresh" in query),
    rest: rest,
  };
}

export async function handleFunctionRoute(
  request: Request,
  env: Environment,
  context: ExecutionContext
) {
  const url = getParsedUrl(request);
  if (!url.path.startsWith("/fn")) return null;
  if (!(url.path in functionManifest)) return new Response(null, { status: 404 });

  const path = url.path as keyof typeof functionManifest;
  const functionConfig = functionManifest[path] as { [method: string]: Function };
  const functionMethod = functionConfig[request.method.toLowerCase()];
  const functionQuery = splitFunctionQuery(url.query, env);

  if (functionQuery.refresh) {
    // REFRESH CACHE
  }

  if (functionConfig.cache && !functionQuery.preview) {
    const storeQueryString = new URLSearchParams(functionQuery.rest).toString();
    const storeKey = url.path + (storeQueryString.length ? "?" + storeQueryString : "");
    const { value, metadata } = await env.DATA.getWithMetadata(storeKey, { type: "stream" });

    if (value) return new Response(value, {
      status: 200,
      headers: {
        "Content-Type": (metadata as { [key: string]: any }).contentType,
        "X-Data-Cache": "HIT"
      }
    });
  }

  let functionResult = null;
  try { functionResult = await functionMethod(functionQuery.rest); }
  catch { return new Response("FUNCTION_ERROR", { status: 500 }); }
  if (!functionResult) return new Response("FUNCTION_RESULT", { status: 500 });

  if (functionConfig.cache && !functionQuery.preview) {
    // PUT IN CACHE
  }

  return new Response(functionResult?.data, {
    status: 200,
    headers: {
      "Content-Type": functionResult?.contentType || "text/plain",
      "X-Data-Cache": !functionConfig.cache && functionQuery.preview ? "PREVIEW" : "NONE"
    }
  });
}

export default {
  async fetch(request: Request, env: Environment, context: ExecutionContext) {
    let response = await handleFunctionRoute(request, env, context);
    if (!response) response = new Response("INVALID_ROUTE", { status: 500 });
    return response;
  }
};
